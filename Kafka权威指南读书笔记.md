# Kafka权威指南读书笔记
## 第一章 初始Kafka
- 发布与订阅消息系统：发布者以某种方式对消息进行分类，接收者
（订阅者）订阅它们，以便接收特定类型的消息。发布与订阅系统一般会有一个broker ，也就是发布消息的中心点。
- 文件系统或数据库提交日志用来提供所有事务的持久记录，通过重放这些日志可以重建系统的状态
- Kafka的数据按照一定顺序持久化保存，可以按需读取
- Kafka的数据分布在整个系统里，具备数据故障保护和性能伸缩能力
- 消息
    - Kafka的数据单元，由字节数组组成。消息有一个可选的键，也是一个字节数组，可用于取模后进行消息分区
    - 消息会被分批写入Kafka，一批内的消息属于同一个主题或分区。批次的大小需要在时间延迟和吞吐量上做权衡。批次数据会被压缩，有利于存储和传输，但使用时需要额外计算开销
    - 消息可以具有模式（Schema），如JSON或XML，或者Apache Avro（常用）
- 主题和分区
    - Kafka的消息通过主题进行分类（类似数据库的表或文件系统的文件夹）
    - 主题可以被分为若干个分区，一个分区就是一个提交日志
    - 消息以追加的方式写入分区，以FIFO顺序读取
    - 由于主题一般包含几个分区，因此无法在整个主题范围内保证消息顺序，只能保证消息在单个分区中有序
    - Kafka通过分区实现数据冗余和伸缩性（分区可以分布在不同服务器上，使主题横跨多服务器）
- 生产者
    - 创建消息，一般情况下消息会被发布到一个特定主题上，均衡分布到该主题下所有分区中（也能用消息键和分区器写到特定分区）
- 消费者
    - 读取消息，订阅一个或多个主题，按消息生成的顺序读取
    - 可以通过检查消息的偏移量来区分已读取的消息
- 偏移量
    - 每个消息携带的元数据，偏移量都是唯一的
    - 不断递增的整数
    - 消费者把每个分区最后读取的偏移量保存在ZooKeeper或Kafka上，以便关闭或重启后恢复读取状态
- 消费者群组
    - 由一个或多个消费者组成，共同读取某个主题
    - 群组保证每个分区只能被一个消费者使用
    - 一个消费者可以读多个分区
    - 消费者与分区之间的关系通常被称为所有权关系
    - 通过这种方式，消费者可以消费包含大量消息的主题，且若出现消费者失效，群组内其它消费者可进行工作接管
- broker
    - 一个独立的Kafka服务器
    - 接收来自生产者的消息，为消息设置偏移量，提交消息到磁盘保存
    - 对消费者读取分区的请求作出响应，返回磁盘上的消息
    - 单broker具备处理千级分区和每秒百万级的消息量
    - 每个集群有一个broker充当集群控制器的角色（自动选举）
    - 控制器负责管理，如将分区分配给broker、监控broker
    - 一个分区从属于一个broker，该broker即为该分区的首领
    - 一个分区可以分配给多个broker（以分区复制的方式提供消息冗余）
    - broker失效时其它broker可以接管首领权，但需要相关的生产者与消费者重新连接
- 保留消息
    - Kafka默认的消息保留策略是保存一段时间或消息达到一定字节数后删除旧消息
    - 主题可以配置自己的保留策略（比如保留到不再使用为止）
    - 可以通过配置把主题当作紧凑型日志， 只有最后一个带有特定键的消息会被保留下来（变更点）
- Kafka建议部署在多集群的原因：
    - 数据类型分离
    - 安全需求隔离
    - 多数据中心（灾难恢复）
- Kafka的消息复制仅限于集群内。集群间的消息复制需要用到MirrorMaker，其本质也是在两个集群间维护消息队列，消费者从一个集群读取消息后，由生产者发布至另一集群
- Kafka的优势
    - 多个生产者：从多个系统中收集数据并以统一格式对外提供，使消费者无需协调不同生产者间的数据流
    - 多个消费者：多个消费者从单消息流上各自读取数据，互不影响。且可设定群组共享消息流并保证每条消息只处理一次
    - 基于磁盘的数据存储：支持持久化非实时消息读取
    - 伸缩性：broker可由少到多灵活扩展
    - 高性能：通过横向扩展生产者、消费者和broker，可保证亚秒级的大数据消息处理延迟
# Kafka权威指南读书笔记
## 第一章 初识Kafka
- 发布与订阅消息系统：发布者以某种方式对消息进行分类，接收者
（订阅者）订阅它们，以便接收特定类型的消息。发布与订阅系统一般会有一个broker ，也就是发布消息的中心点。
- 文件系统或数据库提交日志用来提供所有事务的持久记录，通过重放这些日志可以重建系统的状态
- Kafka的数据按照一定顺序持久化保存，可以按需读取
- Kafka的数据分布在整个系统里，具备数据故障保护和性能伸缩能力
- 消息
    - Kafka的数据单元，由字节数组组成。消息有一个可选的键，也是一个字节数组，可用于取模后进行消息分区
    - 消息会被分批写入Kafka，一批内的消息属于同一个主题或分区。批次的大小需要在时间延迟和吞吐量上做权衡。批次数据会被压缩，有利于存储和传输，但使用时需要额外计算开销
    - 消息可以具有模式（Schema），如JSON或XML，或者Apache Avro（常用）
- 主题和分区
    - Kafka的消息通过主题进行分类（类似数据库的表或文件系统的文件夹）
    - 主题可以被分为若干个分区，一个分区就是一个提交日志
    - 消息以追加的方式写入分区，以FIFO顺序读取
    - 由于主题一般包含几个分区，因此无法在整个主题范围内保证消息顺序，只能保证消息在单个分区中有序
    - Kafka通过分区实现数据冗余和伸缩性（分区可以分布在不同服务器上，使主题横跨多服务器）
- 生产者
    - 创建消息，一般情况下消息会被发布到一个特定主题上，均衡分布到该主题下所有分区中（也能用消息键和分区器写到特定分区）
- 消费者
    - 读取消息，订阅一个或多个主题，按消息生成的顺序读取
    - 可以通过检查消息的偏移量来区分已读取的消息
- 偏移量
    - 每个消息携带的元数据，偏移量都是唯一的
    - 不断递增的整数
    - 消费者把每个分区最后读取的偏移量保存在ZooKeeper或Kafka上，以便关闭或重启后恢复读取状态
- 消费者群组
    - 由一个或多个消费者组成，共同读取某个主题
    - 群组保证每个分区只能被一个消费者使用
    - 一个消费者可以读多个分区
    - 消费者与分区之间的关系通常被称为所有权关系
    - 通过这种方式，消费者可以消费包含大量消息的主题，且若出现消费者失效，群组内其它消费者可进行工作接管
- broker
    - 一个独立的Kafka服务器
    - 接收来自生产者的消息，为消息设置偏移量，提交消息到磁盘保存
    - 对消费者读取分区的请求作出响应，返回磁盘上的消息
    - 单broker具备处理千级分区和每秒百万级的消息量
    - 每个集群有一个broker充当集群控制器的角色（自动选举）
    - 控制器负责管理，如将分区分配给broker、监控broker
    - 一个分区从属于一个broker，该broker即为该分区的首领
    - 一个分区可以分配给多个broker（以分区复制的方式提供消息冗余）
    - broker失效时其它broker可以接管首领权，但需要相关的生产者与消费者重新连接
- 保留消息
    - Kafka默认的消息保留策略是保存一段时间或消息达到一定字节数后删除旧消息
    - 主题可以配置自己的保留策略（比如保留到不再使用为止）
    - 可以通过配置把主题当作紧凑型日志， 只有最后一个带有特定键的消息会被保留下来（变更点）
- Kafka建议部署在多集群的原因：
    - 数据类型分离
    - 安全需求隔离
    - 多数据中心（灾难恢复）
- Kafka的消息复制仅限于集群内。集群间的消息复制需要用到MirrorMaker，其本质也是在两个集群间维护消息队列，消费者从一个集群读取消息后，由生产者发布至另一集群
- Kafka的优势
    - 多个生产者：从多个系统中收集数据并以统一格式对外提供，使消费者无需协调不同生产者间的数据流
    - 多个消费者：多个消费者从单消息流上各自读取数据，互不影响。且可设定群组共享消息流并保证每条消息只处理一次
    - 基于磁盘的数据存储：支持持久化非实时消息读取
    - 伸缩性：broker可由少到多灵活扩展
    - 高性能：通过横向扩展生产者、消费者和broker，可保证亚秒级的大数据消息处理延迟

## 第二章 安装Kafka
- Kafka使用Zookeeper保存集群的元数据信息和消费者信息，因此可以在Zookeeper上查看Kafka集群状态（如主题、分区、复制数等）
- Zookeeper
    - Zookeeper集群被称为群组
    - 使用是一致性协议，所以建议每个群组里应该包含奇数个节点因为只有当群组里的大多数节点（超过半数）处于可用状态，Zookeeper才能处理外部的请求。并且群组节点过多会导致群组性能下降（一般不超过7个）
    - 更改群组配置（包括增加节点）会需要依次重启每一个节点
    - 节点间通信使用TCP协议，首领选举的TCP端口与通信端口不一样
- Kafka会把所有消息保存在磁盘上，存放日志片段的目录由log.dirs指定。如果指定了多个路径，则broker会把同一个分区的片段保存在同一路径下，且会用“最少使用”原则分配目录（**基于文件数，而不是空间大小**）
- Kafka自动创建主题的时机（可以关掉）：
    - 生产者往主题写入消息
    - 消费者从主题读取消息
    - 客户端向主题发送元数据请求
- 主题下分区的数目只增不减
- 选定分区数量时需要考量的因素：
    - 主题的吞吐量
    - 从单个分区读取数据的最大吞吐量
    - 生产者向单个分区写入数据的最大吞吐量
    - 每个broker包含的分区个数、可用的磁盘空间和网络带宽
    - 如果消息按照键来指定分区写入，增加分区会变得困难
    - 单个broker对分区个数有限，由于内存占用和首领选举时间
- 消息会被写入日志片段，日志片段大小可以设置，写满一个之后会关闭，然后开启一个新片段。片段被关闭后才开始计算过期时间。因此一个消息真正的有效时间是（**写入日志后到日志关闭的时间 + 过期时间**）
- 用时间戳获取偏移量时，Kafka会根据日志片段修改时间（已关闭的）找到包含该时间戳的日志片段，并返回日志片段开头的偏移量。因此日志片段越小，结果越准确
- 磁盘性能影响生产者，内存影响消费者
- 消费者一般从分区尾部读取消息，如果有生产者存在，则紧跟着生产者，此时消息会直接存放在系统的页面缓存中，比磁盘上读取快
- 决定broker数量考虑的因素：
    - 单个broker的磁盘空间及集群需要保留的空间数（如果开启复制则需要加倍）
    - 集群处理请求的能力

## 第三章 Kafka生产者——向Kafka写入数据
- 生产者向Broker写入数据前，需要经过序列化->分区器->记录批次几个步骤
- 写入成功后Broker会返回一条元数据记录，否则会重试，若最终还是失败，则返回错误消息
- 生产者只需要知道两个broker信息，因为可以通过broker获取其它broker信息。第二个用来容错
- 发送消息的方式：
    1. 发送并忘记（fire-and-forget）：发送后并不关心是否到达。大多数情况下消息会正常到达，因为Kafka的高可用性会自动尝试重发
    2. 同步发送：使用send()方法发送消息，返回一个Future对象，调用get()进行等待，获取发送结果
    3. 异步发送：在使用send()方法时指定一个回调函数，服务器在返回响应时调用该函数
- 当连接失败或出现无首领异常的时候，消息会自动重发，因为这些问题可解决（重建连接、重新选举）。但如果碰到诸如消息过大这类错误，则不会重试，直接抛出异常
- 生产者的配置：
    - acks：指定必须要有多少个分区副本收到消息，才认为消息写入成功。0代表不用等，1代表首领节点收到消息（如果暂时没首领，生产者会收到错误响应并重发消息，若没收到消息的新节点成为首领则消息会丢失），all代表所有参与复制的节点收到消息
    - buffer.memory：生产者内存缓冲区大小，用于缓冲发送到服务器的消息。当产生消息速度大于发送速度时，send()有可能在此处阻塞
    - max.block.ms：调用send()方法或使用partitionsFor()方法获取元数据时生产者最大阻塞时间。如缓冲区被阻塞或没有可用的元数据时会导致此阻塞，超时会抛出异常
    - compression.type：默认不采用压缩，但使用压缩可以降低网络传输开销和存储开销，即Kafka发送消息的瓶颈
    - retries：失败后消息重发次数，亦可手动设置重试间隔
    - batch.size：消息批次大小，不一定要满了才发，有可能按时发
    - linger.ms：消息批次发送最大等待时间
    - max.in.flight.requests.per.connection：在收到服务器响应前可以发送多少个消息，设置为1时可以保证消息被顺序写入（即使发生了重试）
    - timeout.ms、request.timeout.ms和metadata.fetch.timeout.ms：超时重试时间，超时后要么重试要么返回错误（抛出异常或执行回调）
    - max.request.size：单请求中消息最大值，最好与broker端接收消息配置匹配，以免消息不能被broker接收
    - receive.buffer.bytes和send.buffer.bytes：TCP socket接收和发送数据包的缓冲区大小。设为-1则使用操作系统默认值。生产者或消费者与Broker处于不同数据中心时可以适当增大，因为一般这样的网络延迟高带宽低
- 分区：
    - 当键为空时，分区器使用轮询（Round Robin）算法将消息均衡分布到各个区上
    - 当键不为空时，分区器对键做散列映射到特定分区上。做散列时会用到同一主题下所有分区（不管是否可用），所以有可能写到不可用的分区，导致错误，但这情况不常见
    - 创建主题时把分区规划好，否则后续新增分区会导致散列值计算不一致
    - 可以自定义分区策略，以免出现数据倾斜


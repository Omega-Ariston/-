# 操作系统导论读书笔记
## 第一部分 虚拟化
### 第二章 操作系统介绍
- 冯·诺依曼计算模型基本概念：处理器从内存中获取一条指令，对其进行解码，然后执行它，完成这条指令后处理器继续执行下一条指令，直到程序最终完成
- 虚拟化：操作系统将物理资源（如处理器、内存或磁盘）转换为更通用、更强大且更易于使用的虚拟形式。因此操作系统亦被称作虚拟机
- 操作系统会提供系统调用（几百个）让应用程序使用，它们可被用于运行程序、访问内存和设备，并进行其它操作。这些系统调用的集合亦被称作标准库

### 第四章 抽象：进程
- 进程API：创建、销毁、等待、其它控制（如暂停、继续）、状态
- 进程创建：
    1. 从磁盘中将代码和静态数据加载到内存中
    2. 为程序的运行时栈分配内存（如局部变量、函数参数、返回地址），并用参数初始化栈（将argc、argv数组参数填入main函数）
    3. 为程序的堆分配内存（通过调用malloc函数进行分配以及调用free函数进行释放）
    4. 执行其它初始化任务，特别是I/O相关任务，例如UNIX系统中每个进程的3个打开文件描述符：标准输入、标准输出、错误
    5. 启动程序，在入口处运行（main方法）

### 第五章 插叙：进程API
- fork：子进程与父进程几乎完全一样（子进程不会从main方法开始执行，而是从fork方法返回处开始执行，就像是它自己调用了fork一样。子进程与父进程有不同的返回值，子进程返回0，父进程返回子进程pid）
- wait：调用wait方法后父进程会等待所有子进程执行完毕后再返回
- exec：与fork不同的地方在于fork创建的是父子一样的进程，而exec可以为子进程指定新的程序内容，包括加载新的代码和静态数据（在原始子进程上直接替换）。对exec的成功调用永远不会返回，仿佛子进程在运行exec之前的事情从未发生过一般

### 第六章 机制：受限直接执行
- 构建CPU虚拟化机制的挑战：
    1. 尽可能少地增加系统开销
    2. 有效地运行进程同时要保留对CPU的控制权
- 内核通过在启动时设置陷阱表来约束系统调用。当机器启动时，它在内核模式下执行，因此可以根据需要自由配置机器硬件
- 操作系统做的第一件事就是告诉硬件在发生某些异常事件时要运行哪些代码，如硬盘中断、键盘中断、或程序进行系统调用时应该执行的代码。当硬件被通知到这些代码位置后，会记录下来直至下一次重新启动机器
- main函数结束后会返回到内核模式下的一些存根代码，用于正确地退出程序（如通过exit系统调用）
- 当进程发生切换时，OS会将A进程的内核寄存器保存在特定数据结构中，并将B进程的内核寄存器从特定的数据结构中恢复。如此一来，A进程刚刚陷入内核状态就变得像是B进程刚刚陷入了内核状态

### 第七章 进程调度：介绍
- 进程调度需要考虑的指标：周转时间（最短完成任务优先）、响应时间（时间片轮转）。这两个指标通常无法同时满足，需要权衡
- 上下文切换的成本不仅仅来自保存和恢复少量寄存器的操作系统操作，还有CPU高速缓存、TLB、分支预测器和其它片上硬件中建立的大量状态也会被刷新，可能导致显著的性能成本
- 处理带有I/O操作的任务时，可以将每次CPU请求作为一个单独的任务看待（而不是把整个任务当作一个任务进行调度）

### 第八章 调度：多级反馈队列
- MLFQ有多个优先级不同的队列，每个队列中的任务会由轮转方式执行。高优先级队列中的任务会被优先执行
- MLFQ不会为每个工作指定不变的优先级，而是会根据观察到的行为进行调整，总而言之，交互型作业（如不断放弃CPU来等待键盘输入的作业）会趋向于高优先级，CPU占用型作业会趋向于低优先级
- MLFQ的基本规则：
    1. 优先级高的任务会先于优先级低的任务执行
    2. 优先级相同的任务会以时间片轮转的方式运行
    3. 工作进入系统时，直接放在最高优先级队列中
    4. 工作用完在某一优先级中的时间配额时优先级降低一级
    5. 每隔一段时间，就把所有工作重新加入到最高优先级队列（避免饥饿）
- 一般而言，高优先级队列的运行时间片会短些，以保证交互性，低优先级队列的运行时间会长些，以保证效率
- 有的MLFQ实现会用固定的表数值进行配置，而有的会用数学公式调整优先级
- 有的MLFQ会将最高优先级队列设置为操作系统专属
- 有的MLFQ会允许用户给出建议的任务优先级

### 第十章 多处理器调度（高级）
- 多处理器与单CPU之间的基本区别：对硬件缓存（cache）的使用以及多处理器之间共享数据的方式
- 多处理器调度需要考虑的问题：缓存一致性、缓存亲和度
- 单队列的方式（SQMS）比较容易构建，负载均衡较好，但在扩展性和缓存亲和度方面有着固有的缺陷。多队列的方式（MQMS）有很好的扩展性和缓存亲和度，但实现负载均衡却很困难，也更复杂
- Linux社区的三种调度程序：O(1)调度程序、完全公平调度程序（CFS）、BF调度程序（BFS）
- O(1)与CFS采用多队列，BFS采用单队列
- O(1)是基于优先级的，使交互性得到了特别关注
- CFS是确定的比例调度方法（类似于步长调度）
- BFS也是基于比例调度，但方案更复杂，称为“最早最合适虚拟截止时间优先算法”（EEVEF）
- 步长调度：每个程序有自己的“票数”（与任务的工作量或优先级成正比），用一个大数除以票数得到步长，因此票数越多，步长越小。每当需要调度时，选择当前行程最小的任务进行调度，并让其行程增加步长值

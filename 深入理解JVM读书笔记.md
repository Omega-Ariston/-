# 深入理解JVM读书笔记

## 第二部分 自动内存管理
### 第二章 Java内存区域与内存溢出异常
- 每个线程有自己的程序计数器
- 程序计数器是唯一没有规定OOM的JVM内存区域
- 执行本地方法时程序计数器值为空
- 每个方法执行时都会在方法栈上创建一个栈帧，存储局部变量表（基本数据类型，实例的reference引用，字节码的returnAddress）、操作数栈、动态连接、方法出口等信息
- 虚拟机栈和本地方法栈会stackoverflow，但如果jvm支持栈容量动态扩展，则当扩展到空间不足时会触发OOM（HotSpot不支持）
- HotSpot虚拟机合并了本地方法栈与虚拟机栈
- 堆仅用于分配对象和数组
- 堆的垃圾回收机制以G1作为分界线（是否按新老分代回收）
- 所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区
（Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率
- Java对象有可能之后会不分配在堆上（逃逸分析？值类型支持？）
- 方法区：放置已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等
- 运行时常量池可以动态改变，如String.intern()方法
- 过一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中
- JDK1.4中加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据
- 当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程
- 内存分配的两种思路：
    1. 指针碰撞，用指针分隔使用过的内存和空闲内存，分配时仅仅移动指针即可，但需要保证内存空间规整，一般由GC是否带有空间压缩(Compact)整理来决定
    2. 空闲列表，允许内存空间不规整，具有全局视野。
- 不同类型的垃圾回收算法搭配不同类型的内存分配方式
- 对于指针碰撞而言，有可能出现多线程竞争同一区域的问题，此处可以通过同步处理来保证线程安全（CAS重试），亦或是使用前面提到的TLAB，即每个线程会在Java堆中预留一块区域进行对象缓存，只有当用完这块区域等待分配新区域时才会进行同步锁定。可通过-XX：+/-UseTLAB进行设定。
- 虚拟机分配内存后需要将内存内容设置为0，启用TLAB时可以在分配TLAB时进行。这样当对象创建后字段可以不用设定初始值，使用默认值。
- 创建对象的内存分配完成后，虚拟机会对对象头的信息做初始化，其中包括了GC分代信息，类信息，hashcode（延迟生成），偏向锁信息等。
- HotSpot虚拟机中对象分为三部分：对象头，实例数据，对齐填充
- 对于java数组，对象头中还需要存储其长度
- 实例数据的存储顺序受虚拟机分配策略参数（-XX：FieldsAllocationStyle）和其在对象源码中定义的顺序影响，默认的分配策略中，相同宽度的字段会被分配到一起，如long和double，short和char，byte和boolean。如果+XX：CompactFields为true，则子类中较窄的变量可以插入父类变量的空隙中以节省少部分空间。
- 对齐填充仅用于占位，因为HotSpot虚拟机管理内存要求对象起始地址为8字节的整数倍。
- 栈中的本地变量表存储的对象reference有两种类型：
    1. 句柄，此时JVM需要单独句柄池空间，通过句柄在池中找到对象的真实内存地址，当对象地址变化时直接修改句柄池内的指针即可，池中也会存储实例对象的类对象信息
    2. 直接引用，reference直接对对象进行访问，可以节省一次指针定位的开销，但是需要考虑如何在内存中存储指向类对象信息的指针（放在实例对象信息中？）Hotspot主要使用这种方式。
- -XX：+HeapDumpOnOutOf-MemoryError让内存溢出时Dump出当前的堆内存快照
- **_出现栈溢出时，如果是由于建立过多线程导致，则需要减少最大堆内存及栈的容量来允许更多线程的分配（比较反直觉）_**
- DirectByteBuffer在分配内存过大时会抛出异常，但并没有向操作系统分配内存，而是通过计算得出内存无法分配而手动抛出异常。直接分配内存的地方在Unsafe::allocateMemory()
- 如果OOM后dump出的内存没明显异常或者是文件很小，可以检查直接内存使用方面的原因，如使用了NIO等。

### 第三章 垃圾收集器与内存分配策略
- 引用计数法的原理简单，判定效率高，但有许多例外情况要考虑，如对象间的循环引用问题
- 可达性分析算法：规定一系列的GC Roots，并维护对象间的引用链，若对象不可达gc root，则为不再使用的对象。固定作为GC Root的对象有：
    1. 虚拟机栈（栈帧的本地变量表）中引用的对象
    2. 方法区中类静态属性引用的对象
    3. 方法区中常量引用的对象，如字符串常量池中的对象
    4. 本地方法栈中引用的对象
    5. JVM内部的引用，如基本数据类型对应的class对象，一些常驻的异常对象，如NPE，以及系统类加载器
    6. 被同步锁(synchronized)持有的对象
    7. 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等（？）
    8. 在某些垃圾回收算法中会临时加入一些对象，比如以局部回收作为垃圾回收策略时，回收区域的对象有可能被其它区域的对象引用，此时应该把相关联的区域的对象也加入GC Roots进行可达性分析
- 软引用：在即将抛出OOM前会将这些对象纳入回收范围内进行第二次回收，若此次还未有足够内存释放，则抛出OOM
- 对象被回收前要经过两个标记阶段：
    1. 当GC Root不可达时被标记
    2. 当finalize()没必要执行（未被覆盖/已执行过一次）时被标记
    - 在第2阶段时对象有机会救回自己，如在finalize()方法中让this被引用链上的对象引用，但只有一次机会，因为下次不会再执行finalize()方法了
    - 当finalize()有必要执行时，会被放进一个队列中被低优先级线程调用，但不保证顺利执行，以防缓慢的程序逻辑拖慢队列进度。
- 判断是否可以从方法区中卸载一个类时（不保证一定卸载），需要满足三个条件：
    1. 堆中没有此类的实例对象
    2. 该类对应的类加载器已经被回收，除了在某些可替换类加载器的场景下（OSGi、JSP的重加载）以外，此条件难以达成
    3. 该类对应的.class对象没有在任何地方被引用
- HotSpot虚拟机与类回收相关的参数：
    - 控制是否对类进行回收：-Xnoclassgc
    - 查看类加载与类卸载信息：-verbose：class以及-XX：+TraceClass-Loading、-XX：+TraceClassUnLoading，Unloading版需要在FastDebug版虚拟机中使用
- 分代回收的一个难点在于对象之间有可能存在跨代引用，虽然极少数（理论上被引用的对象大部分是共存亡），但如果出现这种情况，可以通过将老年代分区，并在新生代用Remember Set数据结构来保存其引用的老年代区域信息，便可避免对老年代进行全局扫描。但需要在对象引用关系发生改变（如赋值）时维护这块信息，增加运行时开销
- GC类型：
    - Partial GC:
        - Minor/Young GC：发生在新生代
        - Major/Old GC：发生在老年代，目前只有CMS这么干（偶尔有资料用Major GC表示Full GC）
        - Mixed GC：新生代和部分老年代的回收，目前只有G1这么干
    - Full GC：针对整个Java堆和方法区进行回收
- 新生代中的分区思想为半区回收，基于此思想及新生代对象特征（朝生夕灭）的回收算法为“标记-复制”算法，但实际上用以接收存活对象的空间不需要占去一半的空间，因此更优化的策略是Eden:From:To = 8:1:1，意味着90%的空间可以由新生代对象使用，当to空间不足时由额外空间担保（一般是老年代）
- 老年代中使用“标记-整理”算法，以减少内存空间碎片，是一种移动式算法，直接将存活对象往内存空间一端移动，再清理掉边界外的所有内容。此算法移动对象时代价较大，需要Stop the World。若不采用移动式算法，如“标记-清除”算法，则需要将大内存空间的分配交给更为复杂的内存分配器，如基于空闲分配链表的分配器，但会增加内存访问的额外开销，使应用程序吞吐量下降。
- Parallel Scavenge使用标记-整理算法保证高吞吐量
- CMS使用标记-清除算法保证低延时，但在内存碎片过多以至于影响大对象分配时会用一次标记-整理算法
- 查找引用链的过程可以与用户线程并发，但根节点枚举必须要STW，以保证根节点不会在枚举过程中发生引用变化导致分析不准确
- JVM有办法知道哪些地方存放着对象引用，而不用扫描执行上下文或全局的引用位置去获知。在类加载时会计算出对象数据内的类型及偏移量，以及在即时编译时，会在SafePoint记录下栈和寄存器中哪些位置是引用。存放的数据结构叫OopMap，供收集器扫描时使用。
- 到达Safepoint的线程才能暂停等待垃圾回收，Safepoint的设立准则是：是否具有让代码长时间运行的能力。比如方法调用、循环跳转、异常跳转，会触发安全点的设定
- 在垃圾回收开始前通知所有线程去安全点集合的两种思路：
    1. 抢先式中断：直接中断所有线程，如果该线程不在安全点上，就再让它继续跑到安全点。（几乎没有虚拟机用这个）
    2. 主动式中断：设置一个标志位，当线程运行到某些位置时会轮询这个标志位，一旦收到通知，便在最近的安全点上主动挂起。轮询标志的位置与安全点重合，除此之外还要在所有创建对象或分配内存的地方设置轮询位置，以检查是否将要执行垃圾回收，以防没有足够空间分配。
- 当线程不处于运行状态时（如sleep,block）安全点不生效，此时需要安全区域（Safe Region）。安全区域中代码的引用关系不会发生变化，在此区域中的垃圾回收是安全的。
- 当用户线程进入到安全区域时会标识自己进入了安全区域，此时垃圾收集会对该线程不与理会（不强求STW），当线程离开时会检查jvm是否完成了根节点枚举，或是其它需要暂停线程的操作，若未完成，则在安全区域内等待完成信号。
- 关于Remembered Set的记录精度：
    1. 字长精度：直接记录跨代指针引用地址
    2. 对象精度：记录包含跨代指针引用的对象
    3. 卡精度：记录包含2中对象的内存区域，使用Card Table进行记录（HotSpot用字节数组来实现）。
- 卡表的更新使用了基于AOP思想的“写屏障”技术，在每次赋值后都会触发写后屏障。
- 多线程对卡表并发写时，若更新的对象都位于CPU缓存行中缓存的卡表内容所记录的内存中时，会导致缓存的伪共享问题。一个解决方案是在写卡表时先判断卡表是否已被写，若已则不写，此条件判断由-XX：+UseCondCardMark参数控制，用户可以在条件判断造成的损耗和CPU缓存伪共享的损耗之间权衡。
- 与用户线程并发构建引用链时出现对象消失问题的两个条件（以三色法表达）：
    1. 灰->白的引用关系被全部断开
    2. 黑->白的引用关系被新增
    - 例如：在黑->灰->白的引用关系中，白色本应即将被标记，但如果在黑形成之后，断开灰->白，并连接黑->白，此时黑不会再被扫描，导致白不会被标记。
- 针对破坏以上两个条件的方法为：
    1. 原始快照：当灰->白的关系被删除时，作下记录，等扫描结束后再假定这些关系没被删，将关系中的灰色节点当作root再做一次扫描。
    2. 增量更新：当黑->白的关系被新增时，作下记录，等扫描结束后将这些关系中的黑色节点当作root再做一次扫描。
    - G1、Shenandoah用原始快照做并发标记
    - CMS用增量更新做并发标记

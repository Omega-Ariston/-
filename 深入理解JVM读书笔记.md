# 深入理解JVM读书笔记

## 第二部分 自动内存管理
### 第二章 Java内存区域与内存溢出异常
- 每个线程有自己的程序计数器
- 程序计数器是唯一没有规定OOM的JVM内存区域
- 执行本地方法时程序计数器值为空
- 每个方法执行时都会在方法栈上创建一个栈帧，存储局部变量表（基本数据类型，实例的reference引用，字节码的returnAddress）、操作数栈、动态连接、方法出口等信息
- 虚拟机栈和本地方法栈会stackoverflow，但如果jvm支持栈容量动态扩展，则当扩展到空间不足时会触发OOM（HotSpot不支持）
- HotSpot虚拟机合并了本地方法栈与虚拟机栈
- 堆仅用于分配对象和数组
- 堆的垃圾回收机制以G1作为分界线（是否按新老分代回收）
- 所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区
（Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率
- Java对象有可能之后会不分配在堆上（逃逸分析？值类型支持？）
- 方法区：放置已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等
- 运行时常量池可以动态改变，如String.intern()方法
- 过一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中
- JDK1.4中加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据
- 当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程
- 内存分配的两种思路：
    1. 指针碰撞，用指针分隔使用过的内存和空闲内存，分配时仅仅移动指针即可，但需要保证内存空间规整，一般由GC是否带有空间压缩(Compact)整理来决定
    2. 空闲列表，允许内存空间不规整，具有全局视野。
- 不同类型的垃圾回收算法搭配不同类型的内存分配方式
- 对于指针碰撞而言，有可能出现多线程竞争同一区域的问题，此处可以通过同步处理来保证线程安全（CAS重试），亦或是使用前面提到的TLAB，即每个线程会在Java堆中预留一块区域进行对象缓存，只有当用完这块区域等待分配新区域时才会进行同步锁定。可通过-XX：+/-UseTLAB进行设定。
- 虚拟机分配内存后需要将内存内容设置为0，启用TLAB时可以在分配TLAB时进行。这样当对象创建后字段可以不用设定初始值，使用默认值。
- 创建对象的内存分配完成后，虚拟机会对对象头的信息做初始化，其中包括了GC分代信息，类信息，hashcode（延迟生成），偏向锁信息等。
- HotSpot虚拟机中对象分为三部分：对象头，实例数据，对齐填充
- 对于java数组，对象头中还需要存储其长度
- 实例数据的存储顺序受虚拟机分配策略参数（-XX：FieldsAllocationStyle）和其在对象源码中定义的顺序影响，默认的分配策略中，相同宽度的字段会被分配到一起，如long和double，short和char，byte和boolean。如果+XX：CompactFields为true，则子类中较窄的变量可以插入父类变量的空隙中以节省少部分空间。
- 对齐填充仅用于占位，因为HotSpot虚拟机管理内存要求对象起始地址为8字节的整数倍。
- 栈中的本地变量表存储的对象reference有两种类型：
    1. 句柄，此时JVM需要单独句柄池空间，通过句柄在池中找到对象的真实内存地址，当对象地址变化时直接修改句柄池内的指针即可，池中也会存储实例对象的类对象信息
    2. 直接引用，reference直接对对象进行访问，可以节省一次指针定位的开销，但是需要考虑如何在内存中存储指向类对象信息的指针（放在实例对象信息中？）Hotspot主要使用这种方式。
- -XX：+HeapDumpOnOutOf-MemoryError让内存溢出时Dump出当前的堆内存快照
- **_出现栈溢出时，如果是由于建立过多线程导致，则需要减少最大堆内存及栈的容量来允许更多线程的分配（比较反直觉）_**
- DirectByteBuffer在分配内存过大时会抛出异常，但并没有向操作系统分配内存，而是通过计算得出内存无法分配而手动抛出异常。直接分配内存的地方在Unsafe::allocateMemory()
- 如果OOM后dump出的内存没明显异常或者是文件很小，可以检查直接内存使用方面的原因，如使用了NIO等。

### 第三章 垃圾收集器与内存分配策略
- 衡量垃圾收集器的三大指标：**内存占用，吞吐量，延迟**
- 引用计数法的原理简单，判定效率高，但有许多例外情况要考虑，如对象间的循环引用问题
- 可达性分析算法：规定一系列的GC Roots，并维护对象间的引用链，若对象不可达gc root，则为不再使用的对象。固定作为GC Root的对象有：
    1. 虚拟机栈（栈帧的本地变量表）中引用的对象
    2. 方法区中类静态属性引用的对象
    3. 方法区中常量引用的对象，如字符串常量池中的对象
    4. 本地方法栈中引用的对象
    5. JVM内部的引用，如基本数据类型对应的class对象，一些常驻的异常对象，如NPE，以及系统类加载器
    6. 被同步锁(synchronized)持有的对象
    7. 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等（？）
    8. 在某些垃圾回收算法中会临时加入一些对象，比如以局部回收作为垃圾回收策略时，回收区域的对象有可能被其它区域的对象引用，此时应该把相关联的区域的对象也加入GC Roots进行可达性分析
- 软引用：在即将抛出OOM前会将这些对象纳入回收范围内进行第二次回收，若此次还未有足够内存释放，则抛出OOM
- 对象被回收前要经过两个标记阶段：
    1. 当GC Root不可达时被标记
    2. 当finalize()没必要执行（未被覆盖/已执行过一次）时被标记
    - 在第2阶段时对象有机会救回自己，如在finalize()方法中让this被引用链上的对象引用，但只有一次机会，因为下次不会再执行finalize()方法了
    - 当finalize()有必要执行时，会被放进一个队列中被低优先级线程调用，但不保证顺利执行，以防缓慢的程序逻辑拖慢队列进度。
- 判断是否可以从方法区中卸载一个类时（不保证一定卸载），需要满足三个条件：
    1. 堆中没有此类的实例对象
    2. 该类对应的类加载器已经被回收，除了在某些可替换类加载器的场景下（OSGi、JSP的重加载）以外，此条件难以达成
    3. 该类对应的.class对象没有在任何地方被引用
- HotSpot虚拟机与类回收相关的参数：
    - 控制是否对类进行回收：-Xnoclassgc
    - 查看类加载与类卸载信息：-verbose：class以及-XX：+TraceClass-Loading、-XX：+TraceClassUnLoading，Unloading版需要在FastDebug版虚拟机中使用
- 分代回收的一个难点在于对象之间有可能存在跨代引用，虽然极少数（理论上被引用的对象大部分是共存亡），但如果出现这种情况，可以通过将老年代分区，并在新生代用Remember Set数据结构来保存其引用的老年代区域信息，便可避免对老年代进行全局扫描。但需要在对象引用关系发生改变（如赋值）时维护这块信息，增加运行时开销
- GC类型：
    - Partial GC:
        - Minor/Young GC：发生在新生代
        - Major/Old GC：发生在老年代，目前只有CMS这么干（偶尔有资料用Major GC表示Full GC）
        - Mixed GC：新生代和部分老年代的回收，目前只有G1这么干
    - Full GC：针对整个Java堆和方法区进行回收
- 新生代中的分区思想为半区回收，基于此思想及新生代对象特征（朝生夕灭）的回收算法为“标记-复制”算法，但实际上用以接收存活对象的空间不需要占去一半的空间，因此更优化的策略是Eden:From:To = 8:1:1，意味着90%的空间可以由新生代对象使用，当to空间不足时由额外空间担保（一般是老年代）
- 老年代中使用“标记-整理”算法，以减少内存空间碎片，是一种移动式算法，直接将存活对象往内存空间一端移动，再清理掉边界外的所有内容。此算法移动对象时代价较大，需要Stop the World。若不采用移动式算法，如“标记-清除”算法，则需要将大内存空间的分配交给更为复杂的内存分配器，如基于空闲分配链表的分配器，但会增加内存访问的额外开销，使应用程序吞吐量下降。
- Parallel Scavenge使用标记-整理算法保证高吞吐量
- CMS使用标记-清除算法保证低延时，但在内存碎片过多以至于影响大对象分配时会用一次标记-整理算法
- 查找引用链的过程可以与用户线程并发，但根节点枚举必须要STW，以保证根节点不会在枚举过程中发生引用变化导致分析不准确
- JVM有办法知道哪些地方存放着对象引用，而不用扫描执行上下文或全局的引用位置去获知。在类加载时会计算出对象数据内的类型及偏移量，以及在即时编译时，会在SafePoint记录下栈和寄存器中哪些位置是引用。存放的数据结构叫OopMap，供收集器扫描时使用。
- 到达Safepoint的线程才能暂停等待垃圾回收，Safepoint的设立准则是：是否具有让代码长时间运行的能力。比如方法调用、循环跳转、异常跳转，会触发安全点的设定
- 在垃圾回收开始前通知所有线程去安全点集合的两种思路：
    1. 抢先式中断：直接中断所有线程，如果该线程不在安全点上，就再让它继续跑到安全点。（几乎没有虚拟机用这个）
    2. 主动式中断：设置一个标志位，当线程运行到某些位置时会轮询这个标志位，一旦收到通知，便在最近的安全点上主动挂起。轮询标志的位置与安全点重合，除此之外还要在所有创建对象或分配内存的地方设置轮询位置，以检查是否将要执行垃圾回收，以防没有足够空间分配。
- 当线程不处于运行状态时（如sleep,block）安全点不生效，此时需要安全区域（Safe Region）。安全区域中代码的引用关系不会发生变化，在此区域中的垃圾回收是安全的。
- 当用户线程进入到安全区域时会标识自己进入了安全区域，此时垃圾收集会对该线程不与理会（不强求STW），当线程离开时会检查jvm是否完成了根节点枚举，或是其它需要暂停线程的操作，若未完成，则在安全区域内等待完成信号。
- 关于Remembered Set的记录精度：
    1. 字长精度：直接记录跨代指针引用地址
    2. 对象精度：记录包含跨代指针引用的对象
    3. 卡精度：记录包含2中对象的内存区域，使用Card Table进行记录（HotSpot用字节数组来实现）。
- 卡表的更新使用了基于AOP思想的“写屏障”技术，在每次赋值后都会触发写后屏障。
- 多线程对卡表并发写时，若更新的对象都位于CPU缓存行中缓存的卡表内容所记录的内存中时，会导致缓存的伪共享问题。一个解决方案是在写卡表时先判断卡表是否已被写，若已则不写，此条件判断由-XX：+UseCondCardMark参数控制，用户可以在条件判断造成的损耗和CPU缓存伪共享的损耗之间权衡。
- 与用户线程并发构建引用链时出现白色对象消失的两个条件（以三色法表达）：
    1. 灰->白的直接/间接引用关系被全部断开
    2. 黑->白的引用关系被新增
    - 例如：在黑->灰->白的引用关系中，白色本应即将被标记，但如果在黑形成之后，断开灰->白，并连接黑->白，此时黑不会再被扫描，导致白不会被标记。
- 针对破坏以上两个条件的方法为：
    1. 原始快照：当灰->白的关系被删除时，作下记录，等扫描结束后再假定这些关系没被删，将关系中的灰色节点当作root再做一次扫描。
    2. 增量更新：当黑->白的关系被新增时，作下记录，等扫描结束后将这些关系中的黑色节点当作root再做一次扫描。
    - G1、Shenandoah用原始快照做并发标记
    - CMS用增量更新做并发标记
    - 以上对引用关系修改的记录都是基于写屏障实现的
- 经典新生代垃圾收集器：
    - Serial收集器：
        - 使用标记-复制算法
        - 占用额外内存最少
        - JVM客户端模式下默认的新生代收集器
        - 对单核场景友好（如一些客户端虚拟机）
    - ParNew收集器：
        - Serial的多线程并行版本（各垃圾收集线程之间并行）
        - 只有ParNew和Serial能与CMS搭配使用，前者为激活CMS后默认的新生代收集器
        - JDK9后ParNew和CMS只能互相搭配使用
        - 默认线程数与CPU核心数相等，亦可通过-XX：ParallelGCThreads参数配置
    - Parallel Scavenge收集器（吞吐量优先收集器）：
        - 使用标记-复制算法
        - 没有采用最初的收集器框架，因此不能与框架内的老年代收集器共用，所谓的与SerialOld共用其实也是内部自己实现了一个功能一样的老年收集器，而非直接调用。
        - 主要关注用户线程吞吐量（CPU执行时间占比），而非停顿延时
        - -XX：MaxGCPauseMillis参数设置最大停顿时间
        - -XX：GCTimeRatio参数设置垃圾回收时间总占比（吞吐量），这个TimeRatio的计算方式有点怪。
        - Parallel Scavenge有自适应调节策略，通过-XX：+UseAdaptiveSizePolicy参数控制，能动态调节新生代大小、Eden与Survivor的比例、晋升老年代对象大小等参数以提供最合适的停顿时间或最大吞吐量
- 经典老年代垃圾收集器：
    - Serial Old收集器：
        - Serial收集器的老年版本，使用标记-整理算法
        - 一般与Parallel Scavenge搭配使用，或在CMS运行失败（Concurrent Mode Failure）时使用
    - Parallel Old收集器：
        - Parallel Scavenge的老年版本，使用标记-整理算法
        - 亦关注吞吐量，运行多线程并发收集
        - 因为跳脱收集器框架，只能与Parallel Scavenge一起使用（高吞吐两兄弟）
    - CMS收集器：
        - 分为四个步骤：初始标记、并发标记、重新标记、并发清除
        - 初始标记和重新标记仍然需要Stop the World
        - 初始标记只标记GC Root能直接关联到的对象，很快的
        - 并发标记和重新标记是用于解决前面提到的黑白对象增量更新问题
        - 重新标记的停顿时间稍长
        - CMS默认启动的回收线程数是（处理器核心数量+3）/4，因此当核心少于4个时，影响用户线程吞吐量
        - 在并发标记和并发清理过程中用户线程在标记过程后产生的垃圾叫浮动垃圾
        - 如果浮动垃圾过多影响到并发的用户线程中对象分配，会导致CMS运行失效，导致Stop the World的Full GC发生，临时启用Serial Old收集器慢慢收尾
        - -XX：CMSInitiatingOccupancyFraction参数用于控制CMS触发的老年代内存占用百分比（不能像其它收集器一样等满了再收集，毕竟是与用户线程并发的，对留一些空间给对象）
        - 两个在JDK9后被废弃的与整顿内存碎片有关的参数：-XX：+UseCMS-CompactAtFullCollection，在不得不执行Full GC的时候整理碎片。-XX：CMSFullGCsBeforeCompaction，在若干次不整理空间的Full GC后下一次Full GC要整理碎片。
    - G1收集器：
        - 设计目标是实现可控的垃圾收集停顿时间（通过灵活控制最小回收单元Region的数量，以及计算每个Region的垃圾回收价值，维护优先级列表）
        - 不再将内存简单地划分为新生/老年代，或Eden/Survivor，而是将内存分块管理(Region)，每个块都可以扮演其中的任意一个角色
        - Humongous区域用于存储大对象（超过Region内存一半大小）
        - Region大小可用-XX：G1HeapRegionSize设定，取值范围为1MB～32MB，且为2的N次幂
        - 大对象会被存放在N个连续的Humongous Region中，G1平时有点把他们当作老年代来看的
        - 每个region都维护一份Remembered Set，记录**指向自己的Region**并标记其中的Region所属的卡页范围，使用<Region地址, List<卡表索引>>的Map类结构来记录。相当于知道谁指向自己，并且也能追溯来源的内存位置（双向记录）
        - G1也有可能像CMS一样由于老对象回收赶不上新对象分配而发生Concurrent Mode Failure从而触发Full GC
        - 分为四个步骤：初始标记、并发标记、最终标记、筛选回收
        - 每个region都有两个指针（TAMS），用于标记并发回收垃圾时的新对象可以呆的地方（指针以上的内容不会被回收）
        - 只有并发标记是不用Stop the World的
        - 初始标记阶段在Minor GC中同步完成，无额外暂停时间
        - G1中并发标记阶段对引用关系变化的修改相比于CMS中更复杂，所以为异步执行（类似消息队列）
        - 并发标记时也会处理一些并发标记过程中有引用变动的对象
        - 最终标记则是处理并发标记没处理到的最后那一点引用变动对象
- 低延迟垃圾收集器：
    - Shenandoah收集器：
        - 与G1有很多相似处，二者的修改可以反映到对方身上，比如Shenandoah给G1带来了并发失败时的多线程Full GC后备方案
        - 相比于G1，Shenandoah在最终的清理阶段也可以做到与用户线程并发
        - 也是基于Region设计，但不像G1一般区分新生代、老年代，且摒弃了Remembered Set，改为使用维护全局状态的Connection Matrix连接矩阵来记录跨区域引用关系，降低维护记忆集开销以及伪共享发生概率
        - Shenandoah的收集步骤分为9个阶段（.。。。）
            1. 初始标记：停顿时间与GC Root个数相关
            2. 并发标记：与G1一样
            3. 最终标记：与G1一样，将需要回收的Region收集进Collection Set回收集，会有小段停顿
            4. 并发清理：用于清理毫无存活对象的Region
            5. **并发回收**：与前面所有收集器的核心区别，这一步将Region中存活对象复制到空Region中，通过读屏障和“Brooks Pointers”转发指针来解决用户在此期间的对象访问问题。这一步时长取决于回收集的大小
            6. 初始引用更新：这个阶段只是为了设置一个线程集合点，保证第5步中的各回收线程的对象复制已经完成，会产生很小的停顿
            7. 并发引用更新：真正执行引用更新操作，可以与用户线程并发，消耗时间与引用变化数量有关。这个步骤会对物理内存做线性搜索，将引用类型的旧值改为新值
            8. 最终引用更新：修正存在于GC Root中的引用，需要停顿，时长与GC Root数量有关。
            9. 并发清理：经过前面的步骤，回收集中的Region已无存活对象，此时再并发清理一次来回收这些空间，供新对象分配使用
        - Brooks Pointer实际上就是在对象的对象头前面再加上一个指针，正常情况下会指向对象自身地址，但在对象被复制后会指向新的对象地址，用户线程访问对象就用brooks pointer访问就好了，相当于做了一次指针转发。这么设计的风险在于当对象被复制后，但引用被更新前，若用户对对象进行写操作，新对象会无法接收到此信息。所以这里使用了CAS机制来保证对象访问正确性。
        - Shenandoah使用了大量的读屏障（第一个采用的收集器）和写屏障对对象访问的正确性做保障，会带来额外性能开销。针对亮点可以优化的方向是将其改为“引用访问屏障”，只拦截对象中数据类型为引用类型的读写操作，可以省去对原生类型、对象比较、对象加锁等场景中读屏障带来的开销。
    - ZGC收集器：
        - ZGC也采用基于Region的内存区域管理策略（有的资料称其为Page）
        - ZGC的Region可以动态创建和销毁，以及按容量分为：
            1. 小Region：容量2MB，对象<256KB
            2. 中Region：容量32MB，对象>=256KB，<4MB
            3. 大Region：容量可变，但需为2MB整数倍，对象>4MB。
        - 大Region有可能容量比中Region小
        - 大Region只能放一个对象
        - 大Region不会被重分配（代价高）
        - 相比于Shenandoah用读屏障和转发指针的思路，ZGC另辟蹊径地使用了**染色指针**技术来解决并发整理阶段的对象访问问题
        - 染色指针会直接取对象地址中的4个比特位用于存储标记信息，因此有4TB的容量管理限制
        - 染色指针的三大优势：
            1. 当Region中的存活对象被移走后，这个Region可以立即被释放并使用，而不像Shenandoah一样需要等待引用更新后进行清理
            2. ZGC只使用读屏障
            3. 染色指针是一种可扩展的存储结构（当前64位Linux系统下的内存指针前18位仍未被使用）
        - 染色指针技术需要在操作系统层面做一些支持，以正确地识别物理内存地址，比如Solaris/SPARC平台可以通过虚拟地址掩码使机器指令忽略掉染色指针中的标志位，但x86-64平台则需要使用多重映射技术将不同标志位状态下的内存地址映射到同一个物理内存地址上。
        - ZGC收集器的四大步骤：
            1. 并发标记：前后也有初始标记和最终标记（需要短暂停顿），这一步的标记会直接反映在染色指针上，而不是对象上
            2. 并发预备重分配：ZGC每次都会扫描所有Region（因为没有记忆集），将要清理的Regin放入重分配集（Relocation set）。JDK12中ZGC开始支持的类卸载和弱引用处理也在这步完成
            3. 并发重分配：将重分配集中的存活对象复制到新的Region，并用一个转发表记录旧新对象的转向关系，染色指针会记录下这个对象是否位于重分配集中。如果用户线程并发访问这些对象，这次访问会被内存屏障截获并转发到新对象上，**同时修正该引用的值**。这被称为指针的“**自愈**”能力。Region被释放后转发表会依然存在，以保证自愈功能正常。
            4. 并发重映射：修正整个堆中指向重分配集中的所有对象的引用，这个步骤并不着急（利益于自愈能力），所以可以放在下一次回收的并发标记阶段，因为反正都要扫描所有对象的。
        - ZGC的劣势之一在于由于摒弃了记忆集和写屏障，因此不支持分代收集，当并发收集过程中产生的浮动垃圾（通常会被当作存活对象）量大时会让收集器难以喘息
        - ZGC与Parallel Scavenge支持NUMA内存分配（每个CPU核所在的裸晶都有自己管理的内存，相互之间通过InterConnection通道完成内存访问，会比访问自己内存慢很多），会优先尝试在请求线程当前所处的处理器的本地内存上分配对象
- 垃圾收集器的选择：
    - 现实场景中垃圾回收器的选择主要出于以下3个方面的考虑：
        1. 吞吐量：对交互体验要求不高，但需要尽快算出结果的数据分析、科学计算类应用
        2. 延迟：对服务质量需要保证的SLA应用，不想见到事务超时
        3. 内存占用：运行硬件配置较低的客户端应用或嵌入式应用
    - 基于以上三点，考虑的范畴有：
        1. 运行应用的基础硬件设施，如硬件规格、系统架构、处理器数量、内存大小、操作系统等
        2. 使用JDK的发行商、版本、对应JDK规范的版本等
    - 小型应用可以使用不干活的Epsilon收集器。垃圾回收的本质是作为内存管理的一部分，假如应用本身不需要管理（比如运行时间极短或能保证退出前堆内存够用），那什么也不干也不失为一个好选择。
- JDK9前后关于GC日志的查看参数发生过调整（进行了统一化）
- HotSpot虚拟机的-XX：+PrintGCDetails参数，让虚拟机在发生垃圾收集行为时打印内存回收日志，并在进程退出的时候输出当前的内存各区域分配情况
- 大对象是垃圾收集过程中的灾难，需要分配的连续空间大，做对象复制时的开销也大。所以可以用参数-XX：PretenureSizeThreshold设置大于此阈值的对象直接进入老年代（只对Serial和ParNew生效）。
- 对象头中记录的年龄数会随着Minor GC的次数而增加，当增加到15岁时会被加入老年代，老年岁数可通过-XX：MaxTenuringThreshold参数设置
- 如果Survivor空间中相同年龄的所有对象大小总和大于一半空间，则年龄大于等于这些对象的对象就直接进入老年代
- 如果老年代剩余空间大于所有新生代对象占用空间大小，则这些回收是绝对安全的，否则虚拟机会查看担保参数-XX：HandlePromotionFailure值，若允许担保，则再检查老年代剩余的最大连续空间是否大于历次晋升到老年代的对象的平均大小，若大于，则尝试进行带风险的Minor GC，若小于或不允许担保，则进行一次Full GC。这个策略叫**空间分配担保**

### 第四章 虚拟机性能监控、故障处理工具
- jps：虚拟机进程状况工具
    - 可以通过RMI协议查看远程JVM的进程状态
    - 不仅能显示虚拟机主类名，还可以通过参数显示jvm的启动参数、main方法接收的参数，以及主类命名/jar包路径
- jstat：虚拟机统计信息监视工具
    - 亦具备本地、远程监视能力
    - 监视的内容主要分为三大块：类加载、垃圾收集、运行期编译状况
    - 可以指定时间间隔和运行次数
- jinfo：Java配置信息工具
    - 可以实时查看虚拟机的参数，并做部分调整
    - 可以通过-sysprops参数把System.getProperties()的内容打印出来
- jmap：Java内存映像工具
    - 用于生成堆转储快照（dump）
    - 还可以查询finalize执行队列、Java堆和方法区的详细信息，如空间使用率、使用的垃圾收集器等
    - 部分功能在Windows下使用受限
- jhat：虚拟机堆转储快照分析工具
    - 与jmap后的dump文件搭配使用
    - 在localhost的7000端口以http格式显示分析结果
    - 一般不用
- jstack：Java堆栈跟踪工具
    - 生成虚拟机当前时刻的线程快照
    - 一般用于解决线程长时间停顿问题，如线程间死锁、死循环、请求外部资源导致的长时间挂起等
- 其它小工具：
    - javap：Java字节码分析工具
    - jdeps：Java类依赖性分析器
    - jdeprscan：JDK9后提供，搜索JAR包中使用了deprecated的类

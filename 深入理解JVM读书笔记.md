# 深入理解JVM读书笔记

## 第二部分 自动内存管理
### 第二章 Java内存区域与内存溢出异常
- 每个线程有自己的程序计数器
- 程序计数器是唯一没有规定OOM的JVM内存区域
- 执行本地方法时程序计数器值为空
- 每个方法执行时都会在方法栈上创建一个栈帧，存储局部变量表（基本数据类型，实例的reference引用，字节码的returnAddress）、操作数栈、动态连接、方法出口等信息
- 虚拟机栈和本地方法栈会stackoverflow，但如果jvm支持栈容量动态扩展，则当扩展到空间不足时会触发OOM（HotSpot不支持）
- HotSpot虚拟机合并了本地方法栈与虚拟机栈
- 堆仅用于分配对象和数组
- 堆的垃圾回收机制以G1作为分界线（是否按新老分代回收）
- 所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区
（Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率
- Java对象有可能之后会不分配在堆上（逃逸分析？值类型支持？）
- 方法区：放置已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等
- 运行时常量池可以动态改变，如String.intern()方法
- 一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中
- JDK1.4中加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据
- 当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程
- 内存分配的两种思路：
    1. 指针碰撞，用指针分隔使用过的内存和空闲内存，分配时仅仅移动指针即可，但需要保证内存空间规整，一般由GC是否带有空间压缩(Compact)整理来决定
    2. 空闲列表，允许内存空间不规整，具有全局视野。
- 不同类型的垃圾回收算法搭配不同类型的内存分配方式
- 对于指针碰撞而言，有可能出现多线程竞争同一区域的问题，此处可以通过同步处理来保证线程安全（CAS重试），亦或是使用前面提到的TLAB，即每个线程会在Java堆中预留一块区域进行对象缓存，只有当用完这块区域等待分配新区域时才会进行同步锁定。可通过-XX：+/-UseTLAB进行设定。
- 虚拟机分配内存后需要将内存内容设置为0，启用TLAB时可以在分配TLAB时进行。这样当对象创建后字段可以不用设定初始值，使用默认值。
- 创建对象的内存分配完成后，虚拟机会对对象头的信息做初始化，其中包括了GC分代信息，类信息，hashcode（延迟生成），偏向锁信息等。
- HotSpot虚拟机中对象分为三部分：对象头，实例数据，对齐填充
- 对于java数组，对象头中还需要存储其长度
- 实例数据的存储顺序受虚拟机分配策略参数（-XX：FieldsAllocationStyle）和其在对象源码中定义的顺序影响，默认的分配策略中，相同宽度的字段会被分配到一起，如long和double，short和char，byte和boolean。如果+XX：CompactFields为true，则子类中较窄的变量可以插入父类变量的空隙中以节省少部分空间。
- 对齐填充仅用于占位，因为HotSpot虚拟机管理内存要求对象起始地址为8字节的整数倍。
- 栈中的本地变量表存储的对象reference有两种类型：
    1. 句柄，此时JVM需要单独句柄池空间，通过句柄在池中找到对象的真实内存地址，当对象地址变化时直接修改句柄池内的指针即可，池中也会存储实例对象的类对象信息
    2. 直接引用，reference直接对对象进行访问，可以节省一次指针定位的开销，但是需要考虑如何在内存中存储指向类对象信息的指针（放在实例对象信息中？）Hotspot主要使用这种方式。
- -XX：+HeapDumpOnOutOf-MemoryError让内存溢出时Dump出当前的堆内存快照
- **_出现栈溢出时，如果是由于建立过多线程导致，则需要减少最大堆内存及栈的容量来允许更多线程的分配（比较反直觉）_**
- DirectByteBuffer在分配内存过大时会抛出异常，但并没有向操作系统分配内存，而是通过计算得出内存无法分配而手动抛出异常。直接分配内存的地方在Unsafe::allocateMemory()
- 如果OOM后dump出的内存没明显异常或者是文件很小，可以检查直接内存使用方面的原因，如使用了NIO等。

### 第三章 垃圾收集器与内存分配策略
- 衡量垃圾收集器的三大指标：**内存占用，吞吐量，延迟**
- 引用计数法的原理简单，判定效率高，但有许多例外情况要考虑，如对象间的循环引用问题
- 可达性分析算法：规定一系列的GC Roots，并维护对象间的引用链，若对象不可达gc root，则为不再使用的对象。固定作为GC Root的对象有：
    1. 虚拟机栈（栈帧的本地变量表）中引用的对象
    2. 方法区中类静态属性引用的对象
    3. 方法区中常量引用的对象，如字符串常量池中的对象
    4. 本地方法栈中引用的对象
    5. JVM内部的引用，如基本数据类型对应的class对象，一些常驻的异常对象，如NPE，以及系统类加载器
    6. 被同步锁(synchronized)持有的对象
    7. 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等（？）
    8. 在某些垃圾回收算法中会临时加入一些对象，比如以局部回收作为垃圾回收策略时，回收区域的对象有可能被其它区域的对象引用，此时应该把相关联的区域的对象也加入GC Roots进行可达性分析
- 软引用：在即将抛出OOM前会将这些对象纳入回收范围内进行第二次回收，若此次还未有足够内存释放，则抛出OOM
- 对象被回收前要经过两个标记阶段：
    1. 当GC Root不可达时被标记
    2. 当finalize()没必要执行（未被覆盖/已执行过一次）时被标记
    - 在第2阶段时对象有机会救回自己，如在finalize()方法中让this被引用链上的对象引用，但只有一次机会，因为下次不会再执行finalize()方法了
    - 当finalize()有必要执行时，会被放进一个队列中被低优先级线程调用，但不保证顺利执行，以防缓慢的程序逻辑拖慢队列进度。
- 判断是否可以从方法区中卸载一个类时（不保证一定卸载），需要满足三个条件：
    1. 堆中没有此类的实例对象
    2. 该类对应的类加载器已经被回收，除了在某些可替换类加载器的场景下（OSGi、JSP的重加载）以外，此条件难以达成
    3. 该类对应的.class对象没有在任何地方被引用
- HotSpot虚拟机与类回收相关的参数：
    - 控制是否对类进行回收：-Xnoclassgc
    - 查看类加载与类卸载信息：-verbose：class以及-XX：+TraceClass-Loading、-XX：+TraceClassUnLoading，Unloading版需要在FastDebug版虚拟机中使用
- 分代回收的一个难点在于对象之间有可能存在跨代引用，虽然极少数（理论上被引用的对象大部分是共存亡），但如果出现这种情况，可以通过将老年代分区，并在新生代用Remember Set数据结构来保存其引用的老年代区域信息，便可避免对老年代进行全局扫描。但需要在对象引用关系发生改变（如赋值）时维护这块信息，增加运行时开销
- GC类型：
    - Partial GC:
        - Minor/Young GC：发生在新生代
        - Major/Old GC：发生在老年代，目前只有CMS这么干（偶尔有资料用Major GC表示Full GC）
        - Mixed GC：新生代和部分老年代的回收，目前只有G1这么干
    - Full GC：针对整个Java堆和方法区进行回收
- 新生代中的分区思想为半区回收，基于此思想及新生代对象特征（朝生夕灭）的回收算法为“标记-复制”算法，但实际上用以接收存活对象的空间不需要占去一半的空间，因此更优化的策略是Eden:From:To = 8:1:1，意味着90%的空间可以由新生代对象使用，当to空间不足时由额外空间担保（一般是老年代）
- 老年代中使用“标记-整理”算法，以减少内存空间碎片，是一种移动式算法，直接将存活对象往内存空间一端移动，再清理掉边界外的所有内容。此算法移动对象时代价较大，需要Stop the World。若不采用移动式算法，如“标记-清除”算法，则需要将大内存空间的分配交给更为复杂的内存分配器，如基于空闲分配链表的分配器，但会增加内存访问的额外开销，使应用程序吞吐量下降。
- Parallel Scavenge使用标记-整理算法保证高吞吐量
- CMS使用标记-清除算法保证低延时，但在内存碎片过多以至于影响大对象分配时会用一次标记-整理算法
- 查找引用链的过程可以与用户线程并发，但根节点枚举必须要STW，以保证根节点不会在枚举过程中发生引用变化导致分析不准确
- JVM有办法知道哪些地方存放着对象引用，而不用扫描执行上下文或全局的引用位置去获知。在类加载时会计算出对象数据内的类型及偏移量，以及在即时编译时，会在SafePoint记录下栈和寄存器中哪些位置是引用。存放的数据结构叫OopMap，供收集器扫描时使用。
- 到达Safepoint的线程才能暂停等待垃圾回收，Safepoint的设立准则是：是否具有让代码长时间运行的能力。比如方法调用、循环跳转、异常跳转，会触发安全点的设定。**此处注意，当处理循环跳转时，由int引导的循环会被视为可数（Counted）循环，不需要等待太久，因此不会被插入安全点，由long引导的循环则会被插入。但在特殊情况下若前者含有缓慢执行代码，会导致垃圾回收时其它线程在safepoint自旋等待**
- 在垃圾回收开始前通知所有线程去安全点集合的两种思路：
    1. 抢先式中断：直接中断所有线程，如果该线程不在安全点上，就再让它继续跑到安全点。（几乎没有虚拟机用这个）
    2. 主动式中断：设置一个标志位，当线程运行到某些位置时会轮询这个标志位，一旦收到通知，便在最近的安全点上主动挂起。轮询标志的位置与安全点重合，除此之外还要在所有创建对象或分配内存的地方设置轮询位置，以检查是否将要执行垃圾回收，以防没有足够空间分配。
- 当线程不处于运行状态时（如sleep,block）安全点不生效，此时需要安全区域（Safe Region）。安全区域中代码的引用关系不会发生变化，在此区域中的垃圾回收是安全的。
- 当用户线程进入到安全区域时会标识自己进入了安全区域，此时垃圾收集会对该线程不与理会（不强求STW），当线程离开时会检查jvm是否完成了根节点枚举，或是其它需要暂停线程的操作，若未完成，则在安全区域内等待完成信号。
- 关于Remembered Set的记录精度：
    1. 字长精度：直接记录跨代指针引用地址
    2. 对象精度：记录包含跨代指针引用的对象
    3. 卡精度：记录包含2中对象的内存区域，使用Card Table进行记录（HotSpot用字节数组来实现）。
- 卡表的更新使用了基于AOP思想的“写屏障”技术，在每次赋值后都会触发写后屏障。
- 多线程对卡表并发写时，若更新的对象都位于CPU缓存行中缓存的卡表内容所记录的内存中时，会导致缓存的伪共享问题。一个解决方案是在写卡表时先判断卡表是否已被写，若已则不写，此条件判断由-XX：+UseCondCardMark参数控制，用户可以在条件判断造成的损耗和CPU缓存伪共享的损耗之间权衡。
- 与用户线程并发构建引用链时出现白色对象消失的两个条件（以三色法表达）：
    1. 灰->白的直接/间接引用关系被全部断开
    2. 黑->白的引用关系被新增
    - 例如：在黑->灰->白的引用关系中，白色本应即将被标记，但如果在黑形成之后，断开灰->白，并连接黑->白，此时黑不会再被扫描，导致白不会被标记。
- 针对破坏以上两个条件的方法为：
    1. 原始快照：当灰->白的关系被删除时，作下记录，等扫描结束后再假定这些关系没被删，将关系中的灰色节点当作root再做一次扫描。
    2. 增量更新：当黑->白的关系被新增时，作下记录，等扫描结束后将这些关系中的黑色节点当作root再做一次扫描。
    - G1、Shenandoah用原始快照做并发标记
    - CMS用增量更新做并发标记
    - 以上对引用关系修改的记录都是基于写屏障实现的
- 经典新生代垃圾收集器：
    - Serial收集器：
        - 使用标记-复制算法
        - 占用额外内存最少
        - JVM客户端模式下默认的新生代收集器
        - 对单核场景友好（如一些客户端虚拟机）
    - ParNew收集器：
        - Serial的多线程并行版本（各垃圾收集线程之间并行）
        - 只有ParNew和Serial能与CMS搭配使用，前者为激活CMS后默认的新生代收集器
        - JDK9后ParNew和CMS只能互相搭配使用
        - 默认线程数与CPU核心数相等，亦可通过-XX：ParallelGCThreads参数配置
    - Parallel Scavenge收集器（吞吐量优先收集器）：
        - 使用标记-复制算法
        - 没有采用最初的收集器框架，因此不能与框架内的老年代收集器共用，所谓的与SerialOld共用其实也是内部自己实现了一个功能一样的老年收集器，而非直接调用。
        - 主要关注用户线程吞吐量（CPU执行时间占比），而非停顿延时
        - -XX：MaxGCPauseMillis参数设置最大停顿时间
        - -XX：GCTimeRatio参数设置垃圾回收时间总占比（吞吐量），这个TimeRatio的计算方式有点怪。
        - Parallel Scavenge有自适应调节策略，通过-XX：+UseAdaptiveSizePolicy参数控制，能动态调节新生代大小、Eden与Survivor的比例、晋升老年代对象大小等参数以提供最合适的停顿时间或最大吞吐量
- 经典老年代垃圾收集器：
    - Serial Old收集器：
        - Serial收集器的老年版本，使用标记-整理算法
        - 一般与Parallel Scavenge搭配使用，或在CMS运行失败（Concurrent Mode Failure）时使用
    - Parallel Old收集器：
        - Parallel Scavenge的老年版本，使用标记-整理算法
        - 亦关注吞吐量，运行多线程并发收集
        - 因为跳脱收集器框架，只能与Parallel Scavenge一起使用（高吞吐两兄弟）
    - CMS收集器：
        - 分为四个步骤：初始标记、并发标记、重新标记、并发清除
        - 初始标记和重新标记仍然需要Stop the World
        - 初始标记只标记GC Root能直接关联到的对象，很快的
        - 并发标记和重新标记是用于解决前面提到的黑白对象增量更新问题
        - 重新标记的停顿时间稍长
        - CMS默认启动的回收线程数是（处理器核心数量+3）/4，因此当核心少于4个时，影响用户线程吞吐量
        - 在并发标记和并发清理过程中用户线程在标记过程后产生的垃圾叫浮动垃圾
        - 如果浮动垃圾过多影响到并发的用户线程中对象分配，会导致CMS运行失效，导致Stop the World的Full GC发生，临时启用Serial Old收集器慢慢收尾
        - -XX：CMSInitiatingOccupancyFraction参数用于控制CMS触发的老年代内存占用百分比（不能像其它收集器一样等满了再收集，毕竟是与用户线程并发的，对留一些空间给对象）
        - 两个在JDK9后被废弃的与整顿内存碎片有关的参数：-XX：+UseCMS-CompactAtFullCollection，在不得不执行Full GC的时候整理碎片。-XX：CMSFullGCsBeforeCompaction，在若干次不整理空间的Full GC后下一次Full GC要整理碎片。
    - G1收集器：
        - 设计目标是实现可控的垃圾收集停顿时间（通过灵活控制最小回收单元Region的数量，以及计算每个Region的垃圾回收价值，维护优先级列表）
        - 不再将内存简单地划分为新生/老年代，或Eden/Survivor，而是将内存分块管理(Region)，每个块都可以扮演其中的任意一个角色
        - Humongous区域用于存储大对象（超过Region内存一半大小）
        - Region大小可用-XX：G1HeapRegionSize设定，取值范围为1MB～32MB，且为2的N次幂
        - 大对象会被存放在N个连续的Humongous Region中，G1平时有点把他们当作老年代来看的
        - 每个region都维护一份Remembered Set，记录**指向自己的Region**并标记其中的Region所属的卡页范围，使用<Region地址, List<卡表索引>>的Map类结构来记录。相当于知道谁指向自己，并且也能追溯来源的内存位置（双向记录）
        - G1也有可能像CMS一样由于老对象回收赶不上新对象分配而发生Concurrent Mode Failure从而触发Full GC
        - 分为四个步骤：初始标记、并发标记、最终标记、筛选回收
        - 每个region都有两个指针（TAMS），用于标记并发回收垃圾时的新对象可以呆的地方（指针以上的内容不会被回收）
        - 只有并发标记是不用Stop the World的
        - 初始标记阶段在Minor GC中同步完成，无额外暂停时间
        - G1中并发标记阶段对引用关系变化的修改相比于CMS中更复杂，所以为异步执行（类似消息队列）
        - 并发标记时也会处理一些并发标记过程中有引用变动的对象
        - 最终标记则是处理并发标记没处理到的最后那一点引用变动对象
- 低延迟垃圾收集器：
    - Shenandoah收集器：
        - 与G1有很多相似处，二者的修改可以反映到对方身上，比如Shenandoah给G1带来了并发失败时的多线程Full GC后备方案
        - 相比于G1，Shenandoah在最终的清理阶段也可以做到与用户线程并发
        - 也是基于Region设计，但不像G1一般区分新生代、老年代，且摒弃了Remembered Set，改为使用维护全局状态的Connection Matrix连接矩阵来记录跨区域引用关系，降低维护记忆集开销以及伪共享发生概率
        - Shenandoah的收集步骤分为9个阶段（.。。。）
            1. 初始标记：停顿时间与GC Root个数相关
            2. 并发标记：与G1一样
            3. 最终标记：与G1一样，将需要回收的Region收集进Collection Set回收集，会有小段停顿
            4. 并发清理：用于清理毫无存活对象的Region
            5. **并发回收**：与前面所有收集器的核心区别，这一步将Region中存活对象复制到空Region中，通过读屏障和“Brooks Pointers”转发指针来解决用户在此期间的对象访问问题。这一步时长取决于回收集的大小
            6. 初始引用更新：这个阶段只是为了设置一个线程集合点，保证第5步中的各回收线程的对象复制已经完成，会产生很小的停顿
            7. 并发引用更新：真正执行引用更新操作，可以与用户线程并发，消耗时间与引用变化数量有关。这个步骤会对物理内存做线性搜索，将引用类型的旧值改为新值
            8. 最终引用更新：修正存在于GC Root中的引用，需要停顿，时长与GC Root数量有关。
            9. 并发清理：经过前面的步骤，回收集中的Region已无存活对象，此时再并发清理一次来回收这些空间，供新对象分配使用
        - Brooks Pointer实际上就是在对象的对象头前面再加上一个指针，正常情况下会指向对象自身地址，但在对象被复制后会指向新的对象地址，用户线程访问对象就用brooks pointer访问就好了，相当于做了一次指针转发。这么设计的风险在于当对象被复制后，但引用被更新前，若用户对对象进行写操作，新对象会无法接收到此信息。所以这里使用了CAS机制来保证对象访问正确性。
        - Shenandoah使用了大量的读屏障（第一个采用的收集器）和写屏障对对象访问的正确性做保障，会带来额外性能开销。针对这点可以优化的方向是将其改为“引用访问屏障”，只拦截对象中数据类型为引用类型的读写操作，可以省去对原生类型、对象比较、对象加锁等场景中读屏障带来的开销。
    - ZGC收集器：
        - ZGC也采用基于Region的内存区域管理策略（有的资料称其为Page）
        - ZGC的Region可以动态创建和销毁，以及按容量分为：
            1. 小Region：容量2MB，对象<256KB
            2. 中Region：容量32MB，对象>=256KB，<4MB
            3. 大Region：容量可变，但需为2MB整数倍，对象>4MB。
        - 大Region有可能容量比中Region小
        - 大Region只能放一个对象
        - 大Region不会被重分配（代价高）
        - 相比于Shenandoah用读屏障和转发指针的思路，ZGC另辟蹊径地使用了**染色指针**技术来解决并发整理阶段的对象访问问题
        - 染色指针会直接取对象地址中的4个比特位用于存储标记信息，因此有4TB的容量管理限制
        - 染色指针的三大优势：
            1. 当Region中的存活对象被移走后，这个Region可以立即被释放并使用，而不像Shenandoah一样需要等待引用更新后进行清理
            2. ZGC只使用读屏障
            3. 染色指针是一种可扩展的存储结构（当前64位Linux系统下的内存指针前18位仍未被使用）
        - 染色指针技术需要在操作系统层面做一些支持，以正确地识别物理内存地址，比如Solaris/SPARC平台可以通过虚拟地址掩码使机器指令忽略掉染色指针中的标志位，但x86-64平台则需要使用多重映射技术将不同标志位状态下的内存地址映射到同一个物理内存地址上。
        - ZGC收集器的四大步骤：
            1. 并发标记：前后也有初始标记和最终标记（需要短暂停顿），这一步的标记会直接反映在染色指针上，而不是对象上
            2. 并发预备重分配：ZGC每次都会扫描所有Region（因为没有记忆集），将要清理的Regin放入重分配集（Relocation set）。JDK12中ZGC开始支持的类卸载和弱引用处理也在这步完成
            3. 并发重分配：将重分配集中的存活对象复制到新的Region，并用一个转发表记录旧新对象的转向关系，染色指针会记录下这个对象是否位于重分配集中。如果用户线程并发访问这些对象，这次访问会被内存屏障截获并转发到新对象上，**同时修正该引用的值**。这被称为指针的“**自愈**”能力。Region被释放后转发表会依然存在，以保证自愈功能正常。
            4. 并发重映射：修正整个堆中指向重分配集中的所有对象的引用，这个步骤并不着急（得益于自愈能力），所以可以放在下一次回收的并发标记阶段，因为反正都要扫描所有对象的。
        - ZGC的劣势之一在于由于摒弃了记忆集和写屏障，因此不支持分代收集，当并发收集过程中产生的浮动垃圾（通常会被当作存活对象）量大时会让收集器难以喘息
        - ZGC与Parallel Scavenge支持NUMA内存分配（每个CPU核所在的裸晶都有自己管理的内存，相互之间通过InterConnection通道完成内存访问，会比访问自己内存慢很多），会优先尝试在请求线程当前所处的处理器的本地内存上分配对象
- 垃圾收集器的选择：
    - 现实场景中垃圾回收器的选择主要出于以下3个方面的考虑：
        1. 吞吐量：对交互体验要求不高，但需要尽快算出结果的数据分析、科学计算类应用
        2. 延迟：对服务质量需要保证的SLA应用，不想见到事务超时
        3. 内存占用：运行硬件配置较低的客户端应用或嵌入式应用
    - 基于以上三点，考虑的范畴有：
        1. 运行应用的基础硬件设施，如硬件规格、系统架构、处理器数量、内存大小、操作系统等
        2. 使用JDK的发行商、版本、对应JDK规范的版本等
    - 小型应用可以使用不干活的Epsilon收集器。垃圾回收的本质是作为内存管理的一部分，假如应用本身不需要管理（比如运行时间极短或能保证退出前堆内存够用），那什么也不干也不失为一个好选择。
- JDK9前后关于GC日志的查看参数发生过调整（进行了统一化）
- HotSpot虚拟机的-XX：+PrintGCDetails参数，让虚拟机在发生垃圾收集行为时打印内存回收日志，并在进程退出的时候输出当前的内存各区域分配情况
- 大对象是垃圾收集过程中的灾难，需要分配的连续空间大，做对象复制时的开销也大。所以可以用参数-XX：PretenureSizeThreshold设置大于此阈值的对象直接进入老年代（只对Serial和ParNew生效）。
- 对象头中记录的年龄数会随着Minor GC的次数而增加，当增加到15岁时会被加入老年代，老年岁数可通过-XX：MaxTenuringThreshold参数设置
- 如果Survivor空间中相同年龄的所有对象大小总和大于一半空间，则年龄大于等于这些对象的对象就直接进入老年代
- 如果老年代剩余空间大于所有新生代对象占用空间大小，则这些回收是绝对安全的，否则虚拟机会查看担保参数-XX：HandlePromotionFailure值，若允许担保，则再检查老年代剩余的最大连续空间是否大于历次晋升到老年代的对象的平均大小，若大于，则尝试进行带风险的Minor GC，若小于或不允许担保，则进行一次Full GC。这个策略叫**空间分配担保**

### 第四章 虚拟机性能监控、故障处理工具
- jps：虚拟机进程状况工具
    - 可以通过RMI协议查看远程JVM的进程状态
    - 不仅能显示虚拟机主类名，还可以通过参数显示jvm的启动参数、main方法接收的参数，以及主类命名/jar包路径
- jstat：虚拟机统计信息监视工具
    - 亦具备本地、远程监视能力
    - 监视的内容主要分为三大块：类加载、垃圾收集、运行期编译状况
    - 可以指定时间间隔和运行次数
- jinfo：Java配置信息工具
    - 可以实时查看虚拟机的参数，并做部分调整
    - 可以通过-sysprops参数把System.getProperties()的内容打印出来
- jmap：Java内存映像工具
    - 用于生成堆转储快照（dump）
    - 还可以查询finalize执行队列、Java堆和方法区的详细信息，如空间使用率、使用的垃圾收集器等
    - 部分功能在Windows下使用受限
- jhat：虚拟机堆转储快照分析工具
    - 与jmap后的dump文件搭配使用
    - 在localhost的7000端口以http格式显示分析结果
    - 一般不用
- jstack：Java堆栈跟踪工具
    - 生成虚拟机当前时刻的线程快照
    - 一般用于解决线程长时间停顿问题，如线程间死锁、死循环、请求外部资源导致的长时间挂起等
- 其它小工具：
    - javap：Java字节码分析工具
    - jdeps：Java类依赖性分析器
    - jdeprscan：JDK9后提供，搜索JAR包中使用了deprecated的类
### 第五章 调优案例分析与实战
- 使用单JVM实例管理大内存时需要考虑的问题：
    1. 回收大块堆内存导致的长时间停顿（G1的增量回收可以缓解，但需要等ZGC与Shenandoah收集器成熟之后才能相对彻底解决）
    2. 大内存必须要64位虚拟机支持，但压缩指针、处理器缓存行容量等因素会导致其性能略低于32位虚拟机
    3. 必须保证应用足够稳定，大型单体应用如果发生堆内存溢出，几乎无法产生dump（太大了），或难以对dump进行分析，需要用到JMC这种生产环境运维工具
    4. 相同程序在64位机中消耗的内存要更大，由指针膨胀或数据类型对齐补白导致，默认开启的指针压缩可以缓解
- 使用多JVM组建逻辑集群需要考虑的问题：
    1. 节点竞争全局资源，如磁盘资源（尤其并发写），容易导致IO异常
    2. 难以高效率利用某些资源，比如每个节点都会自己建立连接池，可能有的节点池满了有的还空着。可以使用集中式的JNDI解决，但会增加复杂性和额外性能开销
    3. 如果使用32位虚拟机做节点，仍受到内存限制，win平台每个进程只能用2GB，考虑到堆外内存开销，堆只能分1.5G。在某些linux平台（如Solaris）可以提升到3-4G，但也就到这里了
    4. 大量使用本地缓存（如HashMap）的节点应用，在集群中会造成重复缓存浪费内存，可以考虑使用集中式缓存
- 需要关注的堆外内存情况：
    1. 直接内存：可通过-XX：MaxDirectMemorySize调整大小
    2. 线程堆栈：可通过-Xss调整大小
    3. Socket缓存区：每个Socket连接都有Receive和Send两个缓存区，连接多时可能占用大，无法分配内存时会抛出IOException：Too many open files异常
    4. JNI代码：会占用本地方法栈和本地内存
    5. 虚拟机和垃圾收集器：别忘了他们也要消耗内存的
- JIT即时编译器可以在运行时通过热点代码信息收集来将一些调用达到一定次数的方法字节码编译为本地代码以提高运行效率，因此随着运行时间增长，代码会被编译得越来越彻底。但花费的编译时间会占用程序运行时间，可以用参数-Xint关闭。

## 第三部分 虚拟机执行子系统
### 第六章 类文件结构
- Class文件采用类似C语言中结构体一般的伪结构体来存储数据
- Class文件中的数据只有两种类型：无符号数、表
- 无符号数由u1，u2，u4，u8表示占用字节数
- 表由_info作为结尾，Class文件本身亦可视作一张表
- Class文件的内容顺序：
    - 0xCAFEBABE + 版本
    - 常量池：对常量池内元素的引用从1开始，因为0用来表示不引用
    - 访问标志：定义类信息，如是否为接口、是否为public、是否为abstract、是否为final等，目前使用了9/16个标志位
    - 类索引：父类索引与接口索引集合，存储指向常量池中类全限定名、父类全限定名、接口全限定名集合的索引
    - 字段表集合：类变量、实例变量，不包含方法内部的局部变量
    - 方法表集合：会出现重写后的父类方法信息，有可能出现编译器加进来的方法，如类构造器<clinit>()和实例构造器<init>()方法
    - 属性表集合
- 字节码指令部分暂时跳过

### 第七章 虚拟机类加载机制
- 类的生命周期：
    1. 加载
    2. 验证
    3. 准备
    4. 解析
    5. 初始化
    6. 使用
    7. 卸载
- 验证、准备、解析三个部分统称为连接
- 加载、验证、准备、初始化会按顺序地开始，而不是完成，因为实际过程中各个步骤的不同阶段会交叉执行。
- 解析的时机有可能出现在初始化之后
- 类的加载时机并未强制约束
- 类的初始化时机（有且只有）：
    1. 实例化对象、访问静态变量（常量字段在编译期已放入常量池）、调用静态方法
    2. 使用java.lang.reflect包进行反射调用时
    3. 子类被初始化时，要先递归地初始化父类
    4. 虚拟机启动时会先初始化指定的主类（含main方法的那个）
    5. 当使用JDK7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化（？）
    6. 当接口实现了default方法且接口的实现类发生初始化时，要先对接口进行初始化
- 通过子类访问父类的静态字段时，无需触发子类初始化
- 接口在初始化时不要求父类被初始化，在需要使用父接口（如访问其常量）时才会触发初始化
- 类的加载步骤：
    1. 通过类的全限定名来获取此类的二进制字节流
    2. 将字节流中的静态存储结构转化为方法区的运行时数据结构
    3. 在内存中生成该类的java.lang.Class对象，作为此类的数据访问入口
- 对于上述步骤1，获取二进制字节流的方式对于开发者来说有很大的发挥空间
- 数组的加载：
    - 如果数组存储的类型是引用类型，则递归对其进行加载，并将数组标识在加载该类型的类加载器的类名称空间上（以作唯一性标识）
    - 如果数组存储的是基本类型，则将数组与引导类加载器关联
    - 数组类的可访问性与其存储的组件类型一致
- 验证阶段：
    - 文件格式验证：防止字节码中出现恶意代码或无法正确将信息载入内存
    - 元数据验证：是否有父类（只有java.lang.Object没有），是否继承了不被允许继承的类（final类），是否实现了父类或接口类中要求实现的所有方法，字段名、方法名是否与父类冲突等
    - 字节码验证：最复杂的一步，会判断类型转换、方法跳转点、操作数栈类型是否正确等
    - 符号引用验证：发生在解析阶段中将符号引用转化为直接引用的时候，检查类是否缺少或禁止访问它依赖的某些外部资源
- 准备阶段：
    - 为静态变量分配内存并设置初始值，初始值为0，正确的赋值会在初始化阶段进行（常量的初始值会一步到位设置好）
- 解析阶段：
    - 将常量池内的符号引用替换为直接引用
    - 符号引用存储于Class文件中，与虚拟机内存布局无关
    - 直接引用是可以指向目标的指针、相对偏移量或能直接定位到目标的句柄，与虚拟机实现的内存布局相关
    - 虚拟机实现可以根据需要来判断解析发生的时间，比如类加载器加载类的时候，或是在符号引用被使用的时候
    - 解析阶段也会对类、方法或者字段的访问做可访问性检查
    - 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行
- 初始化阶段：
    - 真正开始执行类中编写的Java程序代码
    - 执行类构造器<clinit>()方法，此方法由编译器收集类中所有静态变量赋值和静态语句块中的语句合并而成，此部分代码顺序与Java代码中的编写顺序一致
    - <clinit>()不需要显式调用父类构造器，因为JVM会保证父类的<clinit>()方法会在子类的前面执行完毕
    - <clinit>()方法非必须生成，没静态代码就没有
    - 接口中没有静态语句块，但也会生成<clinit>()方法，因为有变量赋值操作，但其不要求父接口的构造器方法先执行完毕。接口的实现类在初始化时也不要求接口的构造器方法先执行完毕
    - JVM会保证多线程并发触发的<clinit>()方法被正确加锁，但如果其中的内容很长，有可能会导致其它线程阻塞（**这个很隐蔽**）
    - 同一个类加载器下一个类只会初始化一次，因此当其中一个线程退出构造器方法后，其它被阻塞的进程也不会再进入了
- 类与类加载器形成的二元组可以确定一个唯一的类
- JDK9之前的三层类加载器，由父到子顺序为：
    1. 启动类加载器（Bootstrap Class Loader）：
        - 负责加载存放在<JAVA_HOME>\lib目录或者被-Xbootclasspath参数指定的目录下的能够被识别的类
        - 启动类加载器无法直接被Java程序使用，如果想要用它来加载类，直接用null代替类加载器即可（参照ClassLoader.getClassLoader()方法）
    2. 扩展类加载器（Extension Class Loader)：
        - 在sun.misc.Launcher$ExtClassLoader中以Java代码的形式实现，可由Java程序直接调用使用
        - 负责加载<JAVA_HOME>\lib\ext中或者被java.ext.dirs系统变量指定的目录下的能够被识别的类
        - 在JDK9之后被模块化带来的天然扩展能力取代
    3. 应用程序类加载器（Application Class Loader）：
        - 由sun.misc.Launcher$AppClassLoader实现
        - 是ClassLoader类中的getSystemClassLoader()方法返回的值，故又称为系统类加载器
        - 负责加载用户ClassPath中的所有类库，是程序中默认的类加载器
- 双亲委派模型：
    - 当类加载器收到类加载请求，会先将请求递归向父类进行委派，直到最顶层的启动类加载器收到后，若发现无法完成加载（自己负责的范围内没这个类），则子类再自己尝试加载
    - 可以防止用户恶意构造系统自带类或因系统中出现过多同名类而导致混乱
    - 此模型不具有强制性约束。三层类加载器的想法是很好的：越基础的类越在顶层加载。但在特殊场景下会基础类会需要使用用户程序中的代码，比如由启动类加载器加载的JNDI服务，其存在目的是对资源进行查找和集中管理，便需要调用由其它厂商实现、部署在应用程序ClassPath下的JNDI服务提供者接口代码，但显然启动类加载器不认识这些代码
    - 解决上述问题的方式是使用线程上下文类加载器（不优雅的实现），可以让父类加载器委派子类加载器去完成类加载
    - 在JDK6时，JDK提供了java.util.ServiceLoader类，以META-INF/services中的配置信息，辅以责任链模式，才算给SPI的加载提供了一种相对合理的解决方式
    - OSGi通过打破双亲委派模型，使用网状结构来实现了模块化热部署（程序模块连同类加载器一同被替换），其类加载规则如下：
        1. 将以java.*开头的类，委派给父类加载器加载
        2. 否则，将委派列表名单内的类，委派给父类加载器加载
        3. 否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器加载
        4. 否则，查找当前Bundle的ClassPath，使用自己的类加载器加载
        5. 否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载
        6. 否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载
        7. 否则，类查找失败。
- JDK9后的模块化
    - 如果启用了模块化进行封装，模块就可以声明对其他模块的显式依赖，在启动时验证应用程序开发阶段设定好的依赖关系在运行期是否完备，如有缺失那就直接启动失败，从而避免了很大一部分由于类型依赖而引发的运行时异常
    - 可配置的封装隔离机制还解决了原来类路径上跨JAR文件的public类型的可访问性问题（不再是所有地方都能访问到public代码了）。这种访问控制在类的加载过程（解析阶段）中完成
    - 扩展类加载器由平台类加载器（Platform Class Loader）所取代，因为JDK已经基于模块化构建，无需再完成可扩展需求
    - 新版JDK也取消了<JAVA_HOME>\jre目录，因为可以随时根据需要自己用命令打包出一个jre
    - 现在三大类加载器全部继承于jdk.internal.loader.BuiltinClassLoader
    - 现在当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载（破坏了双亲委派）
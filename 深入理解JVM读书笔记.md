# 深入理解JVM读书笔记

## 第二部分 自动内存管理
### 第二章 Java内存区域与内存溢出异常
- 每个线程有自己的程序计数器
-  程序计数器是唯一没有规定OOM的JVM内存区域
- 执行本地方法是程序计数器值为空
- 每个方法执行时都会在方法栈上创建一个栈帧，存储局部变量表（基本数据类型，实例的reference引用，字节码的returnAddress）、操作数栈、动态连接、方法出口等信息
- 虚拟机栈和本地方法栈会stackoverflow，但如果jvm支持栈容量动态扩展，则当扩展到空间不足时会触发OOM（HotSpot不支持）
- HotSpot虚拟机合并了本地方法栈与虚拟机栈
- 堆仅用于分配对象和数组
- 堆的垃圾回收机制以G1作为分界线（是否按新老分代回收）
- 所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区
（Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率
- Java对象有可能之后会不分配在堆上（逃逸分析？值类型支持？）
- 方法区：放置已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等
- 运行时常量池可以动态改变，如String.intern()方法
- 过一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中
- JDK1.4中加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据
- 当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程
- 内存分配的两种思路：
    1. 指针碰撞，用指针分隔使用过的内存和空闲内存，分配时仅仅移动指针即可，但需要保证内存空间规整，一般由GC是否带有空间压缩(Compact)整理来决定
    2. 空闲列表，允许内存空间不规整，具有全局视野。
- 不同类型的垃圾回收算法搭配不同类型的内存分配方式
- 对于指针碰撞而言，有可能出现多线程竞争同一区域的问题，此处可以通过同步处理来保证线程安全（CAS重试），亦或是使用前面提到的TLAB，即每个线程会在Java堆中预留一块区域进行对象缓存，只有当用完这块区域等待分配新区域时才会进行同步锁定。可通过-XX：+/-UseTLAB进行设定。
- 虚拟机分配内存后需要将内存内容设置为0，启用TLAB时可以在分配TLAB时进行。这样当对象创建后字段可以不用设定初始值，使用默认值。
- 创建对象的内存分配完成后，虚拟机会对对象头的信息做初始化，其中包括了GC分代信息，类信息，hashcode（延迟生成），偏向锁信息等。
- HotSpot虚拟机中对象分为三部分：对象头，实例数据，对齐填充
- 对于java数组，对象头中还需要存储其长度
- 实例数据的存储顺序受虚拟机分配策略参数（-XX：FieldsAllocationStyle）和其在对象源码中定义的顺序影响，默认的分配策略中，相同宽度的字段会被分配到一起，如long和double，short和char，byte和boolean。如果+XX：CompactFields为true，则子类中较窄的变量可以插入父类变量的空隙中以节省少部分空间。
- 对齐填充仅用于占位，因为HotSpot虚拟机管理内存要求对象起始地址为8字节的整数倍。
- 栈中的本地变量表存储的对象reference有两种类型：
    1. 句柄，此时JVM需要单独句柄池空间，通过句柄在池中找到对象的真实内存地址，当对象地址变化时直接修改句柄池内的指针即可，池中也会存储实例对象的类对象信息
    2. 直接引用，reference直接对对象进行访问，可以节省一次指针定位的开销，但是需要考虑如何在内存中存储指向类对象信息的指针（放在实例对象信息中？）Hotspot主要使用这种方式。
- -XX：+HeapDumpOnOutOf-MemoryError让内存溢出时Dump出当前的堆内存快照
- **_出现栈溢出时，如果是由于建立过多线程导致，则需要减少最大堆内存及栈的容量来允许更多线程的分配（比较反直觉）_**
- DirectByteBuffer在分配内存过大时会抛出异常，但并没有向操作系统分配内存，而是通过计算得出内存无法分配而手动抛出异常。直接分配内存的地方在Unsafe::allocateMemory()
- 如果OOM后dump出的内存没明显异常或者是文件很小，可以检查直接内存使用方面的原因，如使用了NIO等。

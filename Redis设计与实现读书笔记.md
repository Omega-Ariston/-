# Redis设计与实现读书笔记
## 第一部分 数据结构与对象
### 第2章 简单动态字符串
- 简单动态字符串（SDS）：Redis中的默认字符串表示，并未直接使用C语言传统的空字符结尾字符数组表示
- 在Redis里，C字符串只会作为字面量用于无须对字符串值进行修改的场合，比如打印日志。一旦涉及修改，都需要使用SDS
- 除了保存数据库中的字符串值外，SDS还被用作缓冲区：AOF模块中的AOF缓冲区，以及客户端状态中的输入缓冲区
1. SDS的定义
    - SDS结构由三个属性构成：
        1. int len：记录buf数组中已使用字节的数量，等于SDS所保存字符串的长度
        2. int free：记录buf数组中未使用字节的数量
        3. char buf[]：字节数组，用于保存字符串
    - SDS遵循C字符串以空字符结尾的惯例（以便重用一部分C字符串函数库里的函数），保存1字节空间不计算在len属性里。为空字符额外分配1字节空间及自动添加至字符串末尾等操作都由SDS函数自动完成，对使用者透明
2. SDS与C字符串的区别
    1. 常数复杂度获取字符串长度
        - C字符串并不记录自身的长度信息，取长度时程序必须遍历整个字符串并计数，复杂度为O(N)。SDS则会在len中记录长度，O(1)复杂度取值
    2. 杜绝缓冲区溢出
        - 因为C字符串不记录自身长度，所以strcat假定用户执行函数时已经为目标字符数组分配了足够多内存，但一旦假定不成立就会产生缓冲区溢出
        - SDS API对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，不满足时会动态扩展空间至执行修改所需的大小，再执行实际的修改操作，不会出现溢出问题
    3. 减少修改字符串时带来的内存重分配次数
        - C字符串每次增长或缩短都需要对数组进行内存重分配操作，以避免出现缓冲区溢出或内存泄漏。Redis作为数据库，数据被频繁修改且对速度要求严苛，因此不能采用这种方式
        - 针对上述情况，SDS通过未使用空间，实现了空间预分配和惰性空间释放两种优化策略
        1. 空间预分配
            - 当SDS的空间被扩展时，程序不仅会为SDS分配修改所必须的空间，还会为其分配额外的未使用空间
            - 当修改后SDS长度小于1MB时，程序分配后的free空间与len长度相同（总长度为len的两倍+1）
            - 当修改后SDS长度大于1MB时，程序分配后的free空间为固定的1MB
            - 这种策略能使SDS连续增长N次所需的内存重分配次数从必定N次降低为最多N次
        2. 惰性空间释放
            - 用于优化SDS的字符串缩短操作
            - 字符串缩短时不会立即释放多余的字节空间，以便日后再增长时可以直接使用
            - SDS提供了相应的API，可以在真正有需要时释放未使用空间
    4. 二进制安全
        - C字符串中的字符必须符合某种编码，如ASCII，并且除了字符串的末尾之外不能包含空字符，否则会被程序误认为是字符串结尾，因此C字符串只能保存文本数据，不能保存图片、音视频这类二进制数据
        - 所有SDS API都会以处理二进制的方式来处理DS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤或假设，写入时是什么样，读取时就是什么样
        - SDS使用len属性的值判断字符串是否结束，可以避免C字符串不能存空字符的问题
    5. 对C字符串函数的兼容性
        - SDS因为末尾也设置了空字符，因此可以兼容部分C字符串函数，比如strcasecmp、strcat等，但并不是所有函数都可以兼容
### 第3章 链表
- Redis中每个链表节点使用一个adlist.h/listNode结构来表示：
    - struct listNode *prev：前置节点
    - struct listNode *next：后置节点
    - void *value：节点值
- adlist.h/list中持有上述链表，并提供了其它用户操作：
    - listNode *head：头节点
    - listNode *tail：尾节点
    - unsigned long len：链表包含的节点数量
    - void *(*dup)(void *ptr)：节点值复制函数
    - void (*free)(void *ptr)：节点值释放函数
    - int (*match)(void *ptr, void *key)：节点值对比函数
- Redis的链表实现特性可以总结如下：
    - 双端：链表节点带有prev和next指针
    - 无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点
    - 带表头指针和表尾指针：通过list结构的head指针和tail指针可以O(1)复杂度获取表头和表尾节点
    - 带链表长度计数器：使用list结构的len属性来对list持有的链表节点进行计数，获取节点数量的复杂度为O(1)
    - 多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，因此链表可以保存各种不同类型的值